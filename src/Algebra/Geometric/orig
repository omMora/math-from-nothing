
Require Import init.

Require Import list.
Require Import set.
Require Import card.
Require Import linear_free.
Require Import linear_span.
Require Import linear_subspace.
Require Import plus_sum.

Inductive ga_sign : Set :=
    | ga_pos
    | ga_neg
    | ga_null.
Definition ga_sign_mult (a b : ga_sign) :=
    match a, b with
    | ga_pos, ga_pos => ga_pos
    | ga_pos, ga_neg => ga_neg
    | ga_pos, ga_null => ga_null
    | ga_neg, ga_pos => ga_neg
    | ga_neg, ga_neg => ga_pos
    | ga_neg, ga_null => ga_null
    | ga_null, ga_pos => ga_null
    | ga_null, ga_neg => ga_null
    | ga_null, ga_null => ga_null
    end.

Theorem ga_sign_mult_assoc : ∀ a b c,
        ga_sign_mult a (ga_sign_mult b c) = ga_sign_mult (ga_sign_mult a b) c.
    intros a b c.
    destruct a, b, c; reflexivity.
Qed.
Theorem ga_sign_mult_comm : ∀ a b, ga_sign_mult a b = ga_sign_mult b a.
    intros a b.
    destruct a, b; reflexivity.
Qed.

Declare Scope ga_scope.
Delimit Scope ga_scope with ga.

Definition ga_metric (V : Type) := V → ga_sign.

Section Construct.

Local Open Scope ga_scope.

Context {V : Type}.

Variable metric : ga_metric V.
Let basis_t := prod ga_sign (list V).

Definition ga_equiv1 (b1 b2 : basis_t) :=
    ∃ (l1 l2 : list V) (e : V),
        snd b1 = l1 ++ e :: e :: l2 ∧
        snd b2 = l1 ++ l2 ∧
        fst b2 = ga_sign_mult (fst b1) (metric e).

Definition ga_equiv2 (b1 b2 : basis_t) :=
    ∃ (l1 l2 : list V) (e f : V),
        e ≠ f ∧
        snd b1 = l1 ++ e :: f :: l2 ∧
        snd b2 = l1 ++ f :: e :: l2 ∧
        fst b2 = ga_sign_mult (fst b1) ga_neg.

Definition ga_equiv3 b1 b2 :=
    b1 = b2 ∨
    ((ga_equiv1 b1 b2 ∨ ga_equiv1 b2 b1) ∨ (ga_equiv2 b1 b2 ∨ ga_equiv2 b2 b1)).

Definition ga_single_equiv (a : basis_t) (l : list basis_t) :=
    match l with
    | list_end => True
    | b :: _ => ga_equiv3 a b
    end.

Fixpoint ga_all_equiv (l : list basis_t) :=
    match l with
    | list_end => True
    | b :: c => ga_single_equiv b c ∧ ga_all_equiv c
    end.

Definition ga_equiv0 b1 b2 :=
    b1 = b2 ∨
    ∃ l : list basis_t,
        (∃ l1, b1 :: l1 = l) ∧
        (∃ l2, l2 ++ b2 :: list_end = l) ∧
        ga_all_equiv l.

Lemma all_equiv_conc : ∀ l1 b l2,
        ga_all_equiv l1 → ga_all_equiv (l1 ++ (b :: list_end)) →
        ga_all_equiv (b :: l2) → ga_all_equiv (l1 ++ (b :: l2)).
    intros l1 b l2 l1_equiv l1_equiv2 l2_equiv.
    induction l1.
    -   exact l2_equiv.
    -   split.
        +   destruct l1.
            *   cbn.
                cbn in l1_equiv2.
                apply l1_equiv2.
            *   cbn.
                cbn in l1_equiv.
                apply l1_equiv.
        +   apply IHl1.
            *   cbn in l1_equiv.
                apply l1_equiv.
            *   cbn in l1_equiv2.
                apply l1_equiv2.
Qed.

Lemma all_equiv_lconc : ∀ l1 l2, ga_all_equiv (l1 ++ l2) → ga_all_equiv l1.
    intros l1 l2 l_equiv.
    induction l1.
    -   cbn.
        exact true.
    -   cbn in *.
        destruct l_equiv as [a_equiv l_equiv].
        split.
        +   destruct l1.
            *   cbn.
                exact true.
            *   cbn in *.
                exact a_equiv.
        +   exact (IHl1 l_equiv).
Qed.

Local Notation "a ~ b" := (ga_equiv0 a b) : algebra_scope.
Local Open Scope algebra_scope.
Local Open Scope ga_scope.

Lemma ga_eq_reflexive : ∀ a, a ~ a.
    intros a.
    left.
    reflexivity.
Qed.
Instance ga_eq_reflexive_class : Reflexive _ := {
    refl := ga_eq_reflexive
}.

Lemma ga_eq_symmetric : ∀ a b, a ~ b → b ~ a.
    intros a b [ab|ab].
    1: left; symmetry; exact ab.
    destruct ab as [l [[l1 l1_eq] [[l2 l2_eq] l_equiv]]].
    right.
    exists (list_reverse l).
    repeat split.
    -   exists (list_reverse l2).
        rewrite <- l2_eq.
        rewrite list_reverse_conc.
        cbn.
        reflexivity.
    -   exists (list_reverse l1).
        rewrite <- l1_eq.
        cbn.
        reflexivity.
    -   clear l1 l1_eq l2 l2_eq.
        induction l; trivial.
        cbn.
        cbn in l_equiv.
        destruct l_equiv as [s_equiv l_equiv].
        specialize (IHl l_equiv).
        destruct l.
        +   cbn.
            split; exact true.
        +   cbn in s_equiv.
            cbn.
            rewrite <- list_conc_assoc.
            apply all_equiv_conc.
            *   cbn in IHl.
                apply all_equiv_lconc in IHl.
                exact IHl.
            *   cbn in IHl.
                exact IHl.
            *   cbn.
                repeat split; try exact true.
                destruct s_equiv as [eq|[[e|e]|[e|e]]].
                --  left; symmetry; exact eq.
                --  right; left; right; exact e.
                --  right; left; left; exact e.
                --  right; right; right; exact e.
                --  right; right; left; exact e.
Qed.
Instance ga_eq_symmetric_class : Symmetric _ := {
    sym := ga_eq_symmetric
}.

Lemma ga_eq_transitive : ∀ a b c, a ~ b → b ~ c → a ~ c.
    intros a b c ab bc.
    destruct ab as [ab|ab].
    1: subst; exact bc.
    destruct bc as [bc|bc].
    1: subst; right; exact ab.
    destruct ab as [abl [[abl1 abl1_eq] [[abl2 abl2_eq] abl_equiv]]].
    destruct bc as [bcl [[bcl1 bcl1_eq] [[bcl2 bcl2_eq] bcl_equiv]]].
    right.
    exists (abl ++ bcl).
    repeat split.
    -   exists (abl1 ++ bcl).
        rewrite <- abl1_eq.
        cbn.
        reflexivity.
    -   exists (abl ++ bcl2).
        rewrite <- bcl2_eq.
        rewrite list_conc_assoc.
        reflexivity.
    -   clear abl1 abl1_eq bcl2 bcl2_eq.
        rewrite <- bcl1_eq.
        apply all_equiv_conc; try assumption.
        2: rewrite bcl1_eq; exact bcl_equiv.
        rewrite <- abl2_eq.
        rewrite <- list_conc_assoc.
        apply all_equiv_conc.
        +   rewrite <- abl2_eq in abl_equiv.
            apply all_equiv_lconc in abl_equiv.
            exact abl_equiv.
        +   rewrite abl2_eq.
            exact abl_equiv.
        +   cbn.
            repeat split; try exact true.
            left.
            reflexivity.
Qed.
Instance ga_eq_transitive_class : Transitive _ := {
    trans := ga_eq_transitive
}.

Definition ga_equiv := make_equiv _
    ga_eq_reflexive_class ga_eq_symmetric_class ga_eq_transitive_class.
Notation "a ~ b" := (ga_equiv0 a b) : ga_scope.
Notation "'ga_basis_base'" := (equiv_type ga_equiv).

Context U `{
    UP : Plus U,
    UZ : Zero U,
    UN : Neg U,
    @PlusAssoc U UP,
    @PlusComm U UP,
    @PlusLid U UP UZ,
    @PlusLinv U UP UZ UN,
    UM : Mult U,
    UO : One U,
    @MultComm U UM,
    @MultLid U UM UO,
    @Ldist U UP UM,
    @NotTrivial U UZ UO
}.

Let FR := free_linear U ga_basis_base.
Let to_FR b := to_free U ga_basis_base (to_equiv_type ga_equiv b).

Let FR_plus := free_plus_class U ga_basis_base.
Let FR_zero := free_zero U ga_basis_base.
Let FR_neg := free_neg U ga_basis_base.
Let FR_plus_comm := free_plus_comm_class U ga_basis_base.
Let FR_plus_assoc := free_plus_assoc_class U ga_basis_base.
Let FR_plus_lid := free_plus_lid_class U ga_basis_base.
Let FR_plus_linv := free_plus_linv_class U ga_basis_base.
Let FR_scalar := free_scalar U ga_basis_base.
Let FR_scalar_ldist := free_scalar_ldist_class U ga_basis_base.
Let FR_scalar_rdist := free_scalar_rdist_class U ga_basis_base.
Existing Instances FR_plus FR_zero FR_neg FR_plus_comm FR_plus_assoc FR_plus_lid
    FR_plus_linv FR_scalar FR_scalar_ldist FR_scalar_rdist.

Let sub1 v := ∃ l, v = to_FR (ga_pos, l) + to_FR (ga_neg, l).
Let sub2 v := ∃ l, v = to_FR (ga_null, l).
Let sub := sub1 ∪ sub2.

Definition ga := linear_span_quotient U sub.
Definition b_to_ga b := to_quotient U sub (to_FR b).

Definition ga_plus_class
    := quotient_space_plus (linear_span_subspace U sub).
Definition ga_plus_assoc_class
    := quotient_space_plus_assoc (linear_span_subspace U sub).
Definition ga_plus_comm_class
    := quotient_space_plus_comm (linear_span_subspace U sub).
Definition ga_zero_class
    := quotient_space_zero (linear_span_subspace U sub).
Definition ga_plus_lid_class
    := quotient_space_plus_lid (linear_span_subspace U sub).
Definition ga_neg_class
    := quotient_space_neg (linear_span_subspace U sub).
Definition ga_plus_linv_class
    := quotient_space_plus_linv (linear_span_subspace U sub).
Existing Instances ga_plus_class ga_plus_assoc_class ga_plus_comm_class
    ga_zero_class ga_plus_lid_class ga_neg_class ga_plus_linv_class.

Definition ga_free_basis_scale x := ∃ α b, x = α · to_free U ga_basis_base b.

Theorem ga_free_decompose_basis : ∀ a,
        ∃ (l : list (set_type ga_free_basis_scale)),
        a = list_sum (list_image l (λ x, [x|])).
    intros a.
    destruct a as [af af_fin].
    pose proof (fin_nat0_ex _ af_fin) as [n n_eq].
    unfold nat0_to_card in n_eq; equiv_simpl in n_eq.
    destruct n_eq as [nf nf_bij].
    revert af af_fin nf nf_bij.
    nat0_induction n.
    -   intros.
        exists list_end.
        cbn.
        apply free_eq; cbn.
        intros x.
        unfold zero; cbn.
        classic_contradiction contr.
        pose proof (rand nf_bij [x|contr]) as [m m_eq].
        contradiction (nat0_lt_0_false m).
    -   intros.
        pose (af' x := If x = [nf [n|nat0_lt_suc n]|] then 0 else af x).
        assert (∀ x, af' x ≠ 0 → af x ≠ 0) as af'_neq.
        {
            intros x.
            unfold af'.
            case_if.
            -   intros contr; contradiction.
            -   trivial.
        }
        assert (finite (|set_type (λ x, af' x ≠ 0)|)) as af'_fin.
        {
            apply (le_lt_trans2 af_fin).
            unfold le; equiv_simpl.
            exists (λ x, [[x|] | af'_neq [x|] [|x]]).
            intros a b eq.
            inversion eq as [eq2].
            apply set_type_eq; exact eq2.
        }
        assert (∀ m : (set_type (λ x, x < n)),
            let res := nf [[m|]|trans [|m] (nat0_lt_suc n)] in
            af [res|] ≠ 0 → af' [res|] ≠ 0) as af'_neq2.
        {
            intros [m m_ltq]; cbn.
            intros eq.
            unfold af'; case_if.
            -   apply set_type_eq in e.
                apply nf_bij in e.
                inversion e.
                subst.
                destruct m_ltq; contradiction.
            -   exact eq.
        }
        pose (nf' (x : set_type (λ x, x < n))
            := let res := nf [[x|]|trans [|x] (nat0_lt_suc n)] in
                [[res|] | af'_neq2 _ [|res]] : set_type (λ x, af' x ≠ 0)).
        assert (bijective nf') as nf'_bij.
        {
            unfold nf'.
            split.
            -   intros a b eq.
                inversion eq as [eq2].
                apply set_type_eq in eq2.
                apply nf_bij in eq2.
                inversion eq2 as [eq3].
                apply set_type_eq; exact eq3.
            -   intros [y y_neq].
                specialize (af'_neq y y_neq).
                pose proof (rand nf_bij [y|af'_neq]) as [[x x_ltq] eq].
                pose proof x_ltq as x_ltq2.
                rewrite nat0_lt_suc_le in x_ltq2.
                classic_case (x = n) as [x_eq|x_neq].
                +   exfalso.
                    subst.
                    unfold af' in y_neq.
                    case_if.
                    *   contradiction.
                    *   rewrite (proof_irrelevance _ x_ltq) in n0.
                        rewrite eq in n0.
                        contradiction.
                +   exists [x|make_and x_ltq2 x_neq].
                    apply set_type_eq; cbn.
                    rewrite (proof_irrelevance _ x_ltq).
                    rewrite eq.
                    reflexivity.
        }
        specialize (IHn af' af'_fin nf' nf'_bij) as [l l_eq].
        pose (fn := af [nf [n|nat0_lt_suc n]|] ·
            to_free U ga_basis_base [nf [n|nat0_lt_suc n]|]).
        assert (ga_free_basis_scale fn) as fn_in.
        {
            exists (af [nf [n|nat0_lt_suc n]|]), [nf [n | nat0_lt_suc n]|].
            reflexivity.
        }
        exists (l ++ [fn|fn_in] :: list_end).
        rewrite list_image_conc.
        rewrite list_sum_plus.
        rewrite <- l_eq.
        cbn.
        unfold plus; cbn.
        apply free_eq; cbn.
        intros x.
        unfold af'.
        unfold zero at 7; cbn.
        rewrite plus_rid.
        unfold fn, scalar_mult; cbn.
        case_if.
        *   rewrite plus_lid.
            rewrite mult_rid.
            rewrite e.
            reflexivity.
        *   rewrite mult_ranni.
            rewrite plus_rid.
            reflexivity.
Qed.

Definition ga_mult_base1 a b : basis_t :=
    (ga_sign_mult (fst a) (fst b), snd a ++ snd b).

Lemma ga_all_equiv_wd_lmult : ∀ l a, ga_all_equiv l →
        ga_all_equiv (list_image l (ga_mult_base1 a)).
    intros l a l_equiv.
    induction l; try exact true.
    cbn.
    destruct l_equiv as [a_equiv l_equiv].
    split; try exact (IHl l_equiv).
    clear IHl.
    destruct l; try exact true.
    cbn.
    cbn in a_equiv.
    destruct a_equiv as [eq|[[e|e]|[e|e]]].
    *   rewrite eq.
        left; reflexivity.
    *   right; left; left.
        destruct e as [l1 [l2 [e [eq1 [eq2 s_eq]]]]].
        exists (snd a ++ l1), l2.
        exists e.
        unfold ga_mult_base1; cbn.
        repeat split.
        --  rewrite eq1.
            rewrite list_conc_assoc.
            reflexivity.
        --  rewrite eq2.
            rewrite list_conc_assoc.
            reflexivity.
        --  rewrite s_eq.
            rewrite ga_sign_mult_assoc.
            reflexivity.
    *   right; left; right.
        destruct e as [l1 [l2 [e [eq1 [eq2 s_eq]]]]].
        exists (snd a ++ l1), l2.
        unfold ga_mult_base1; cbn.
        exists e.
        repeat split.
        --  rewrite eq1.
            rewrite list_conc_assoc.
            reflexivity.
        --  rewrite eq2.
            rewrite list_conc_assoc.
            reflexivity.
        --  rewrite s_eq.
            rewrite ga_sign_mult_assoc.
            reflexivity.
    *   right; right; left.
        destruct e as [l1 [l2 [e [f [e_neq [eq1 [eq2 s_eq]]]]]]].
        exists (snd a ++ l1), l2.
        exists e, f.
        unfold ga_mult_base1; cbn.
        repeat split.
        --  exact e_neq.
        --  rewrite eq1.
            rewrite list_conc_assoc.
            reflexivity.
        --  rewrite eq2.
            rewrite list_conc_assoc.
            reflexivity.
        --  rewrite s_eq.
            rewrite ga_sign_mult_assoc.
            reflexivity.
    *   right; right; right.
        destruct e as [l1 [l2 [e [f [e_neq [eq1 [eq2 s_eq]]]]]]].
        exists (snd a ++ l1), l2.
        exists e, f.
        unfold ga_mult_base1; cbn.
        repeat split.
        --  exact e_neq.
        --  rewrite eq1.
            rewrite list_conc_assoc.
            reflexivity.
        --  rewrite eq2.
            rewrite list_conc_assoc.
            reflexivity.
        --  rewrite s_eq.
            rewrite ga_sign_mult_assoc.
            reflexivity.
Qed.

Lemma ga_all_equiv_wd_rmult_single : ∀ a b c,
        ga_equiv3 a b → ga_equiv3 (ga_mult_base1 a c) (ga_mult_base1 b c).
    intros a b c equiv.
    destruct equiv as [eq|[[e|e]|[e|e]]].
    *   rewrite eq.
        left; reflexivity.
    *   right; left; left.
        destruct e as [l1 [l2 [e [eq1 [eq2 s_eq]]]]].
        exists l1, (l2 ++ snd c).
        exists e.
        unfold ga_mult_base1; cbn.
        repeat split.
        --  rewrite eq1.
            do 2 rewrite list_conc_add_assoc.
            rewrite list_conc_assoc.
            reflexivity.
        --  rewrite eq2.
            rewrite list_conc_assoc.
            reflexivity.
        --  rewrite s_eq.
            do 2 rewrite <- ga_sign_mult_assoc.
            rewrite (ga_sign_mult_comm (fst c)).
            reflexivity.
    *   right; left; right.
        destruct e as [l1 [l2 [e [eq1 [eq2 s_eq]]]]].
        exists l1, (l2 ++ snd c).
        unfold ga_mult_base1; cbn.
        exists e.
        repeat split.
        --  rewrite eq1.
            do 2 rewrite list_conc_add_assoc.
            rewrite list_conc_assoc.
            reflexivity.
        --  rewrite eq2.
            rewrite list_conc_assoc.
            reflexivity.
        --  rewrite s_eq.
            do 2 rewrite <- ga_sign_mult_assoc.
            rewrite (ga_sign_mult_comm (fst c)).
            reflexivity.
    *   right; right; left.
        destruct e as [l1 [l2 [e [f [e_neq [eq1 [eq2 s_eq]]]]]]].
        exists l1, (l2 ++ snd c).
        exists e, f.
        unfold ga_mult_base1; cbn.
        repeat split.
        --  exact e_neq.
        --  rewrite eq1.
            do 2 rewrite list_conc_add_assoc.
            rewrite list_conc_assoc.
            reflexivity.
        --  rewrite eq2.
            do 2 rewrite list_conc_add_assoc.
            rewrite list_conc_assoc.
            reflexivity.
        --  rewrite s_eq.
            do 2 rewrite <- ga_sign_mult_assoc.
            rewrite (ga_sign_mult_comm (fst c)).
            reflexivity.
    *   right; right; right.
        destruct e as [l1 [l2 [e [f [e_neq [eq1 [eq2 s_eq]]]]]]].
        exists l1, (l2 ++ snd c).
        exists e, f.
        unfold ga_mult_base1; cbn.
        repeat split.
        --  exact e_neq.
        --  rewrite eq1.
            do 2 rewrite list_conc_add_assoc.
            rewrite list_conc_assoc.
            reflexivity.
        --  rewrite eq2.
            do 2 rewrite list_conc_add_assoc.
            rewrite list_conc_assoc.
            reflexivity.
        --  rewrite s_eq.
            do 2 rewrite <- ga_sign_mult_assoc.
            rewrite (ga_sign_mult_comm (fst c)).
            reflexivity.
Qed.

Lemma ga_all_equiv_wd_rmult : ∀ l a, ga_all_equiv l →
        ga_all_equiv (list_image l (λ x, ga_mult_base1 x a)).
    intros l c l_equiv.
    induction l; try exact true.
    cbn.
    destruct l_equiv as [a_equiv l_equiv].
    split; try exact (IHl l_equiv).
    clear IHl.
    destruct l; try exact true.
    cbn.
    cbn in a_equiv.
    exact (ga_all_equiv_wd_rmult_single _ _ _ a_equiv).
Qed.

Lemma ga_mult_base1_wd1 :
        ∀ a b c, a ~ b → ga_mult_base1 a c ~ ga_mult_base1 b c.
    intros a b c ab.
    destruct ab as [ab|ab].
    1: subst; apply refl.
    destruct ab as [l [[l1 l1_eq] [[l2 l2_eq] l_equiv]]].
    right.
    pose (l' := list_image l (λ x, ga_mult_base1 x c)).
    exists l'.
    repeat split.
    -   exists (list_image l1 (λ x, ga_mult_base1 x c)).
        unfold l'.
        rewrite <- l1_eq.
        cbn.
        reflexivity.
    -   exists (list_image l2 (λ x, ga_mult_base1 x c)).
        unfold l'.
        rewrite <- l2_eq.
        rewrite list_image_conc.
        cbn.
        reflexivity.
    -   unfold l'.
        exact (ga_all_equiv_wd_rmult _ _ l_equiv).
Qed.

Lemma ga_mult_base1_wd2 :
        ∀ a c d, c ~ d → ga_mult_base1 a c ~ ga_mult_base1 a d.
    intros a c d cd.
    destruct cd as [cd|cd].
    1: subst; apply refl.
    destruct cd as [l [[l1 l1_eq] [[l2 l2_eq] l_equiv]]].
    right.
    pose (l' := list_image l (ga_mult_base1 a)).
    exists l'.
    repeat split.
    -   exists (list_image l1 (ga_mult_base1 a)).
        unfold l'.
        rewrite <- l1_eq.
        cbn.
        reflexivity.
    -   exists (list_image l2 (ga_mult_base1 a)).
        unfold l'.
        rewrite <- l2_eq.
        rewrite list_image_conc.
        cbn.
        reflexivity.
    -   exact (ga_all_equiv_wd_lmult _ _ l_equiv).
Qed.

Lemma ga_mult_base1_wd :
        ∀ a b c d, eq_equal ga_equiv a b → eq_equal ga_equiv c d →
        eq_equal ga_equiv (ga_mult_base1 a c) (ga_mult_base1 b d).
    intros a b c d ab cd.
    pose proof (ga_mult_base1_wd1 a b c ab) as eq1.
    pose proof (ga_mult_base1_wd2 b c d cd) as eq2.
    exact (trans eq1 eq2).
Qed.

Definition ga_mult_base2 := binary_self_op ga_mult_base1_wd.
Definition ga_mult_base3 (a b : set_type ga_free_basis_scale) :=
    (ex_val [|a] * ex_val [|b]) · to_free U ga_basis_base
        (ga_mult_base2 (ex_val (ex_proof [|a])) (ex_val (ex_proof [|b]))).
Definition ga_mult_base4 (a b : FR) :=
    list_sum (list_prod2 ga_mult_base3 (ex_val (ga_free_decompose_basis a))
                                       (ex_val (ga_free_decompose_basis b))).

Let equiv2 := eq_equal (subspace_equiv (linear_span_subspace U sub)).

Definition ga_basis_scale x := ∃ α b, x = to_quotient U sub (α · to_FR (ga_pos, b)).

Lemma ga_free_basis_to_basis :
        ∀ x, ga_free_basis_scale x → ga_basis_scale (to_quotient U sub x).
    intros x [α [b x_eq]].
    equiv_get_value b.
    destruct b as [b_sign b].
    destruct b_sign.
    -   exists α, b.
        rewrite x_eq.
        reflexivity.
    -   exists (-α), b.
        rewrite x_eq.
        unfold to_quotient.
        equiv_simpl.
        intros S sub_S.
        rewrite scalar_lneg.
        rewrite neg_neg.
        rewrite <- scalar_ldist.
        apply subspace_scalar.
        apply sub_S.
        left.
        exists b.
        apply plus_comm.
    -   exists 0, b.
        rewrite x_eq.
        unfold to_quotient.
        equiv_simpl.
        rewrite scalar_lanni.
        rewrite neg_zero, plus_rid.
        intros S sub_S.
        apply subspace_scalar.
        apply sub_S.
        right.
        exists b.
        reflexivity.
Qed.

Theorem ga_decompose_basis : ∀ a : ga, ∃ l : list (set_type ga_basis_scale),
        a = list_sum (list_image l (λ x, [x|])).
    intros a.
    equiv_get_value a.
    pose proof (ga_free_decompose_basis a) as [l a_eq].
    subst a.
    induction l.
    -   exists list_end.
        cbn.
        reflexivity.
    -   destruct IHl as [l' l'_eq].
        destruct a as [a a_basis]; cbn in *.
        apply ga_free_basis_to_basis in a_basis.
        exists ([_|a_basis] :: l').
        cbn.
        rewrite <- l'_eq.
        unfold plus at 2, to_quotient; equiv_simpl.
        reflexivity.
Qed.

(*
Lemma ga_mult_base2_wd : ∀ a b c d, equiv2 a b → equiv2 c d →
        equiv2 (ga_mult_base4 a c) (ga_mult_base4 b d).
    intros a b c d ab cd.
    cbn in ab, cd.
    unfold ga_mult_base4.
    cbn.
    old_unpack_ex_val al al_eq.
    old_unpack_ex_val bl bl_eq.
    old_unpack_ex_val cl cl_eq.
    old_unpack_ex_val dl dl_eq.
    subst a b c d.
    intros S sub_S.
    specialize (ab S sub_S).
    specialize (cd S sub_S).
Admitted.

Instance ga_mult : Mult ga := {
    mult := binary_self_op ga_mult_base2_wd
}.
 *)

End Construct.
