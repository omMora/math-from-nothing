Require Import init.

(* begin show *)
Set Universe Polymorphism.
(* end show *)

(** Note: I am learning category theory while writing this.  Apologies if
anything here is incorrect/not specified in the best way.
*)

Reserved Notation "ùüô".
Record CategoryObj := make_category {
    cat_U :> Type;
    morphism : cat_U ‚Üí cat_U ‚Üí Type;
    cat_compose : ‚àÄ {A B C}, morphism B C ‚Üí morphism A B ‚Üí morphism A C
        where "a ‚àò b" := (cat_compose a b);
    cat_id : ‚àÄ A, morphism A A where "ùüô" := (cat_id _);
    cat_assoc : ‚àÄ {A B C D}
        (h : morphism C D) (g : morphism B C) (f : morphism A B),
        h ‚àò (g ‚àò f) = (h ‚àò g) ‚àò f;
    cat_lid : ‚àÄ {A B} (f : morphism A B), ùüô ‚àò f = f;
    cat_rid : ‚àÄ {A B} (f : morphism A B), f ‚àò ùüô = f;
}.

Arguments cat_compose {c A B C} f g.
Arguments morphism {c}.
Arguments cat_id {c}.
Arguments cat_assoc {c A B C D}.
Arguments cat_lid {c A B}.
Arguments cat_rid {c A B}.

Infix "‚àò" := cat_compose.
Notation "ùüô" := (cat_id _).

Definition cat_domain {C : CategoryObj} {A B : C} (f : morphism A B) := A.
Definition cat_codomain {C : CategoryObj} {A B : C} (f : morphism A B) := B.

Definition convert_type {A B : Type} (H : A = B) (x : A) : B.
    destruct H.
    exact x.
Defined.

Theorem cat_eq : ‚àÄ C1 C2,
    ‚àÄ H : cat_U C1 = cat_U C2,
    ‚àÄ H' : (‚àÄ A B, morphism A B =
                   morphism (convert_type H A) (convert_type H B)),
    (‚àÄ A B C (f : morphism B C) (g : morphism A B),
        convert_type (H' _ _) (f ‚àò g) =
        (convert_type (H' _ _) f) ‚àò (convert_type (H' _ _) g)) ‚Üí
    (‚àÄ A, convert_type (H' A A) (cat_id A) = cat_id (convert_type H A)) ‚Üí
    C1 = C2.
Proof.
    intros [U1 morphism1 compose1 id1 assoc1 lid1 rid1]
           [U2 morphism2 compose2 id2 assoc2 lid2 rid2] H H' eq1 eq2.
    cbn in *.
    destruct H. (* Saying subst U2 causes a bug at Qed for some reason *)
    cbn in *.
    assert (morphism1 = morphism2) as eq.
    {
        functional_intros A B.
        apply H'.
    }
    subst morphism2; cbn in *.
    rewrite (proof_irrelevance H' (Œª A B, Logic.eq_refl)) in eq1, eq2.
    clear H'.
    cbn in *.
    assert (compose1 = compose2) as eq.
    {
        functional_intros A B C f g.
        apply eq1.
    }
    subst compose2; clear eq1.
    apply functional_ext in eq2.
    subst id2.
    rewrite (proof_irrelevance assoc2 assoc1).
    rewrite (proof_irrelevance lid2 lid1).
    rewrite (proof_irrelevance rid2 rid1).
    reflexivity.
Qed.

Record FunctorObj (C1 C2 : CategoryObj) := make_functor_base {
    functor_f :> C1 ‚Üí C2;
    functor_morphism : ‚àÄ {A B},
        morphism A B ‚Üí morphism (functor_f A) (functor_f B);
    functor_compose : ‚àÄ {A B C} (f : morphism B C) (g : morphism A B),
        functor_morphism (f ‚àò g) = functor_morphism f ‚àò functor_morphism g;
    functor_id : ‚àÄ A, functor_morphism (cat_id A) = ùüô;
}.

Arguments functor_f {C1 C2} f0 A.
Arguments functor_morphism {C1 C2} f0 {A B} f.
Arguments functor_id {C1 C2}.

Notation "‚åà F ‚åâ" := (functor_morphism F) (at level 40).

Program Definition id_functor (C : CategoryObj) : FunctorObj C C := {|
    functor_f A := A;
    functor_morphism A B f := f;
|}.

Program Definition compose_functor {C1 C2 C3 : CategoryObj}
    (F : FunctorObj C2 C3) (G : FunctorObj C1 C2) : FunctorObj C1 C3 :=
{|
    functor_f a := F (G a);
    functor_morphism A B (f : morphism A B) := ‚åàF‚åâ (‚åàG‚åâ f);
|}.
Next Obligation.
Proof.
    rewrite functor_compose.
    apply functor_compose.
Qed.
Next Obligation.
Proof.
    rewrite functor_id.
    apply functor_id.
Qed.

Definition functor_morphism_convert_type {C1 C2 : CategoryObj}
        {F G : FunctorObj C1 C2} {A B} (H : ‚àÄ A, F A = G A)
        (f : morphism (F A) (F B)) : morphism (G A) (G B).
Proof.
    rewrite (H A) in f.
    rewrite (H B) in f.
    exact f.
Defined.

Theorem functor_eq {C1 C2 : CategoryObj} : ‚àÄ {F G : FunctorObj C1 C2},
        ‚àÄ (H : ‚àÄ A, F A = G A),
        (‚àÄ {A B} (f : morphism A B),
            functor_morphism_convert_type H (‚åàF‚åâ f) = ‚åàG‚åâ f) ‚Üí
        F = G.
Proof.
    intros [f1 morphism1 compose1 id1] [f2 morphism2 compose2 id2] H eq'.
    cbn in *.
    pose proof (functional_ext _ _ _ H) as eq.
    subst f2.
    assert (morphism1 = morphism2) as eq.
    {
        functional_intros A B f.
        rewrite <- eq'.
        unfold functor_morphism_convert_type; cbn.
        rewrite (proof_irrelevance (H A) (Logic.eq_refl)).
        rewrite (proof_irrelevance (H B) (Logic.eq_refl)).
        cbn.
        reflexivity.
    }
    subst morphism2; clear H eq'.
    rewrite (proof_irrelevance compose2 compose1).
    rewrite (proof_irrelevance id2 id1).
    reflexivity.
Qed.

Program Definition Category : CategoryObj := {|
    cat_U := CategoryObj;
    morphism A B := FunctorObj A B;
    cat_compose A B C f g := compose_functor f g;
    cat_id A := id_functor A;
|}.
Next Obligation.
Proof.
    unshelve eapply functor_eq.
    -   reflexivity.
    -   cbn.
        reflexivity.
Qed.
Next Obligation.
Proof.
    unshelve eapply functor_eq.
    -   reflexivity.
    -   cbn.
        reflexivity.
Qed.
Next Obligation.
Proof.
    unshelve eapply functor_eq.
    -   reflexivity.
    -   cbn.
        reflexivity.
Qed.

Record NatTransformationObj {C1 C2 : Category} (F G : morphism C1 C2) :=
make_nat_trans_base {
    nat_trans_f :> ‚àÄ A, morphism (F A) (G A);
    nat_trans_commute : ‚àÄ {A B} (f : morphism A B),
        nat_trans_f B ‚àò (‚åàF‚åâ f) = (‚åàG‚åâ f) ‚àò nat_trans_f A;
}.

Arguments nat_trans_f {C1 C2 F G} n.
Arguments nat_trans_commute {C1 C2 F G} n {A B}.

Program Definition id_nat_transformation {C1 : Category} {C2 : Category}
    (F : morphism C1 C2) : NatTransformationObj F F :=
{|
    nat_trans_f A := ùüô
|}.
Next Obligation.
    rewrite cat_rid.
    apply cat_lid.
Qed.

(* begin show *)
Program Definition vcompose_nat_transformation {C1 C2 : Category}
    {F G H : morphism C1 C2}
    (Œ± : NatTransformationObj G H) (Œ≤ : NatTransformationObj F G)
    : NatTransformationObj F H :=
{|
    nat_trans_f A := Œ± A ‚àò Œ≤ A
|}.
(* end show *)
Next Obligation.
    rewrite cat_assoc.
    rewrite <- cat_assoc.
    rewrite nat_trans_commute.
    rewrite cat_assoc.
    rewrite nat_trans_commute.
    reflexivity.
Qed.

Theorem nat_trans_eq {C1 C2 : Category} {F G : morphism C1 C2} :
    ‚àÄ (Œ± Œ≤ : NatTransformationObj F G), (‚àÄ A, Œ± A = Œ≤ A) ‚Üí Œ± = Œ≤.
Proof.
    intros [f1 commute1] [f2 commute2] eq.
    cbn in eq.
    apply functional_ext in eq.
    subst f2.
    rewrite (proof_irrelevance commute2 commute1).
    reflexivity.
Qed.

Program Definition Functor (C1 C2 : Category) : Category := {|
    cat_U := morphism C1 C2;
    morphism F G := NatTransformationObj F G;
    cat_compose A B C Œ± Œ≤ := vcompose_nat_transformation Œ± Œ≤;
    cat_id F := id_nat_transformation F;
|}.
Next Obligation.
    apply nat_trans_eq.
    intros X.
    cbn.
    apply cat_assoc.
Qed.
Next Obligation.
    apply nat_trans_eq.
    intros X.
    cbn.
    apply cat_lid.
Qed.
Next Obligation.
    apply nat_trans_eq.
    intros X.
    cbn.
    apply cat_rid.
Qed.

Notation "'NatTransformation'" := (morphism (c := Functor _ _)).
Notation "ùüè" := (ùüô : Functor _ _).
Notation "'ùïÄ'" := (ùüô : NatTransformation _ _).

Definition make_functor C1 C2 f a b c
    := make_functor_base C1 C2 f a b c : Functor C1 C2.
Definition make_nat_trans {C1 C2 : Category} (F G : Functor C1 C2) f c
    := @make_nat_trans_base C1 C2 F G f c : NatTransformation F G.

Unset Universe Polymorphism.
